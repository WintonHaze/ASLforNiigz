function [res] = renalRegisterNonrigid(MOVING,FIXED,type)
%registerImages  Register grayscale images using auto-generated code from Registration Estimator app.
%  [MOVINGREG] = registerImages(MOVING,FIXED) Register grayscale images
%  MOVING and FIXED using auto-generated code from the Registration
%  Estimator app. The values for all registration parameters were set
%  interactively in the app and result in the registered image stored in the
%  structure array MOVINGREG.

% Auto-generated by registrationEstimator app on 18-May-2023
%-----------------------------------------------------------

if nargin < 3
    type = 'nonrigid';
end
MYMOVING = MOVING;

% Normalize FIXED image

% Get linear indices to finite valued data
finiteIdx = isfinite(FIXED(:));

% Replace NaN values with 0
FIXED(isnan(FIXED)) = 0;

% Replace Inf values with 1
FIXED(FIXED==Inf) = 1;

% Replace -Inf values with 0
FIXED(FIXED==-Inf) = 0;

% Normalize input data to range in [0,1].
FIXEDmin = min(FIXED(:));
FIXEDmax = max(FIXED(:));
if isequal(FIXEDmax,FIXEDmin)
    FIXED = 0*FIXED;
else
    FIXED(finiteIdx) = (FIXED(finiteIdx) - FIXEDmin) ./ (FIXEDmax - FIXEDmin);
end

% Normalize MOVING image

% Get linear indices to finite valued data
finiteIdx = isfinite(MOVING(:));

% Replace NaN values with 0
MOVING(isnan(MOVING)) = 0;

% Replace Inf values with 1
MOVING(MOVING==Inf) = 1;

% Replace -Inf values with 0
MOVING(MOVING==-Inf) = 0;

% Normalize input data to range in [0,1].
MOVINGmin = min(MOVING(:));
MOVINGmax = max(MOVING(:));
if isequal(MOVINGmax,MOVINGmin)
    MOVING = 0*MOVING;
else
    MOVING(finiteIdx) = (MOVING(finiteIdx) - MOVINGmin) ./ (MOVINGmax - MOVINGmin);
end

if strcmp(type, 'nonrigid') == 1

    % Nonrigid registration
    [D,~] = imregdemons(MOVING,FIXED,100,'AccumulatedFieldSmoothing',1.0,'PyramidLevels',3);
    MOVINGREG = imwarp(MOVING, D, 'SmoothEdges', true);

elseif strcmp(type, 'rigid') == 1

        % Default spatial referencing objects
    fixedRefObj = imref2d(size(FIXED));
    movingRefObj = imref2d(size(MOVING));

    % Intensity-based registration
    [optimizer, metric] = imregconfig('monomodal');
    % optimizer.MaximumStepLength = 1.25000e-03; % mPLD-kidney尝试的步长
    optimizer.MaximumIterations = 1000;

    % Align centers
    fixedCenterXWorld = mean(fixedRefObj.XWorldLimits);
    fixedCenterYWorld = mean(fixedRefObj.YWorldLimits);
    movingCenterXWorld = mean(movingRefObj.XWorldLimits);
    movingCenterYWorld = mean(movingRefObj.YWorldLimits);
    translationX = fixedCenterXWorld - movingCenterXWorld;
    translationY = fixedCenterYWorld - movingCenterYWorld;

    % Coarse alignment
    initTform = affinetform2d();
    initTform.A(1:2,3) = [translationX ; translationY];

    % Apply transformation
    tform = imregtform(MOVING,movingRefObj,FIXED,fixedRefObj,'rigid',optimizer,metric,'PyramidLevels',3,'InitialTransformation',initTform);
    % MOVINGREG.Transformation = tform;
    MOVINGREG.RegisteredImage = imwarp(MOVING, movingRefObj, tform, 'OutputView', fixedRefObj, 'SmoothEdges', true);

    % Store spatial referencing object
    % MOVINGREG.SpatialRefObj = fixedRefObj;
    MOVINGREG = MOVINGREG.RegisteredImage;


elseif strcmp(type, 'mono') == 1

    % Default spatial referencing objects
    fixedRefObj = imref2d(size(FIXED));
    movingRefObj = imref2d(size(MOVING));

    % Intensity-based registration
    [optimizer, metric] = imregconfig('monomodal');
    optimizer.GradientMagnitudeTolerance = 1.00000e-04;
    optimizer.MinimumStepLength = 1.00000e-05;
    optimizer.MaximumStepLength = 2.25000e-02;
    % optimizer.MaximumStepLength = 1.25000e-03; % mPLD-kidney尝试的步长
    optimizer.MaximumIterations = 700;
    optimizer.RelaxationFactor = 0.500000;

    % Align centers
    fixedCenterXWorld = mean(fixedRefObj.XWorldLimits);
    fixedCenterYWorld = mean(fixedRefObj.YWorldLimits);
    movingCenterXWorld = mean(movingRefObj.XWorldLimits);
    movingCenterYWorld = mean(movingRefObj.YWorldLimits);
    translationX = fixedCenterXWorld - movingCenterXWorld;
    translationY = fixedCenterYWorld - movingCenterYWorld;

    % Coarse alignment
    initTform = affinetform2d();
    initTform.A(1:2,3) = [translationX ; translationY];

    % Apply transformation
    tform = imregtform(MOVING,movingRefObj,FIXED,fixedRefObj,'affine',optimizer,metric,'PyramidLevels',3,'InitialTransformation',initTform);
    % MOVINGREG.Transformation = tform;
    MOVINGREG.RegisteredImage = imwarp(MOVING, movingRefObj, tform, 'OutputView', fixedRefObj, 'SmoothEdges', true);

    % Store spatial referencing object
    % MOVINGREG.SpatialRefObj = fixedRefObj;
    MOVINGREG = MOVINGREG.RegisteredImage;

end

% De-normalize
res = MOVINGREG .* (MOVINGmax - MOVINGmin) + MOVINGmin;
% res = res .* mean(mean(MYMOVING)) ./mean(mean(res));

end

